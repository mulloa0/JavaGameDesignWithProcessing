/* autogenerated by Processing revision 1286 on 2023-06-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.Color;
import java.awt.Polygon;
import java.awt.Point;
import java.util.ArrayList;
import java.awt.Polygon;
import java.awt.Point;
import java.util.ArrayList;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Game extends PApplet {

/* Game Class Starter File
 * Last Edit: 5/22/23
 * Authors: _____________________
 */

//import processing.sound.*;

//GAME VARIABLES
private int timesGet = 0;
private int msElapsed = 0;
String titleText = "Murder Mystery";
String extraText = "Mansion Conspiracy -Maria & Sadia";

//Screens
Screen currentScreen;
World currentWorld;
Grid currentGrid;

//Splash Screen Variables
Screen splashScreen;
String splashBgFile = "images/mansion.jpg";
PImage splashBg;

//Main Screen Variables
Grid mainGrid;
String mainBgFile = "images/mansion living room.png";
PImage mainBg;

//Basement Screen Variables
Grid basementGrid;
String basementBgFile = "images/basement.PNG";
PImage basementBg;

AnimatedSprite p1;
String p1File = "sprites/MC_AKey.png";
String p1json = "sprites/MC_AKey.json";
int player1Row = 3;
int player1Col = 2;
int health = 3;

AnimatedSprite enemySprite;
PImage enemy;
String enemyFile = "";
// AnimatedSprite exampleSprite;
boolean doAnimation;    

ArrayList<String> marks = new ArrayList<String>();
ArrayList<String> items = new ArrayList<String>();
PImage key; 
String keyFile = "images/key.png";
PImage drawer;
String drawerFile = "images/drawer.png";
PImage hairclip;
String hairclipFile = "images/hairclip-removebg-preview.png";
PImage tv;
String tvFile = "images/tv-removebg-preview.png";
PImage knight;
String knightfile = "images/x_wood.png";
PImage fingerprint;
String fingerprintFile = "images/fingerprint.png";
PImage hairstrand;
String hairstrandFile = "images/Hair.png";

//EndScreen variables
World endScreen;
PImage endBg;
String endBgFile = "images/youwin.png";

//Example Variables
//HexGrid hGrid = new HexGrid(3);
//SoundFile song;



//Required Processing method that gets run once
 public void setup() {

  //Match the screen size to the background image size
  /* size commented out by preprocessor */;

  //Set the title on the title bar
  surface.setTitle(titleText);

  //Pixel width of one tile: 40
  //Pixel height of one tile: 30
  
  //Load BG images used
  splashBg = loadImage(splashBgFile);
  splashBg.resize(width, height);
  mainBg = loadImage(mainBgFile);
  mainBg.resize(width, height);
  basementBg = loadImage(basementBgFile);
  basementBg.resize(width, height);
  endBg = loadImage(endBgFile);
  endBg.resize(width, height);

  //setup the screens/worlds/grids in the Game
  splashScreen = new Screen("splash", splashBg);
  mainGrid = new Grid("living room", mainBg, 18,16);
  basementGrid = new Grid("basement", basementBg, 18,16);
  endScreen = new World("end", endBg);
  currentScreen = splashScreen;
  currentGrid = mainGrid;

  //Setup player1 animation
  playerAnimationSetup();

  //setup the item images
  key = loadImage(keyFile);
  key.resize(50,50);
  drawer = loadImage(drawerFile);
  drawer.resize(80,60);
  hairclip = loadImage(hairclipFile);
  hairclip.resize(80,60);
  tv = loadImage(tvFile);
  tv.resize(120,90);
  knight = loadImage(knightfile);
  knight.resize(120,90);
  fingerprint = loadImage(fingerprintFile);
  fingerprint.resize(40,30);
  hairstrand = loadImage(hairstrandFile);
  hairstrand.resize(120,90);

  //set up the items into the first Grid
  itemSetup1();


  // exampleSprite = new AnimatedSprite("sprites/horse_run.png", "sprites/horse_run.json");
  // exampleAnimationSetup();

  // Load a soundfile from the /data folder of the sketch and play it back
  // song = new SoundFile(this, "sounds/Lenny_Kravitz_Fly_Away.mp3");
  // song.play();

   imageMode(CORNER);    //Set Images to read coordinates at corners
  //fullScreen();   //only use if not using a specfic bg image
  println("Game started...");
}

//Required Processing method that automatically loops
//(Anything drawn on the screen should be called from here)
 public void draw() { 


  

  updateTitleBar();

  // if (msElapsed % 300 == 0) {
  //   populateSprites();
  //   moveSprites();
  // }

  updateScreen();
  
  if(isGameOver()){
    endGame();
  }

  //checkExampleAnimation();
  
  msElapsed +=100;
  currentGrid.pause(100);


}

//Known Processing method that automatically will run whenever a key is pressed
 public void keyPressed(){

  //check what key was pressed
  System.out.println("Key pressed: " + keyCode); //keyCode gives you an integer for the key

  //What to do when a key is pressed?B
  

  //set "w" key to move the player1 up
  if(player1Row !=1 && keyCode == 87){
    
    //Erase image from previous location
    GridLocation oldLoc = new GridLocation(player1Row, player1Col);
    
    currentGrid.clearTileSprite(oldLoc);

    //change the field for player1Row
    player1Row--;
    
    


  }
if(player1Row != currentGrid.getNumRows()-3 && keyCode == 83){
    //check case where out of bounds (key s)
    
    //Erase image from previous location
    GridLocation oldLoc = new GridLocation(player1Row, player1Col);
    currentGrid.clearTileSprite(oldLoc);

    //change the field for player1Row
    player1Row++;

  }
 if(player1Col != currentGrid.getNumCols()-1 && keyCode == 68){

    //Erase image from previous location
    GridLocation oldLoc = new GridLocation(player1Row, player1Col);
    currentGrid.clearTileSprite(oldLoc);

    //change the field for player1Col
    player1Col++;
  }
  if(player1Col !=1 && keyCode == 65){

    //Erase image from previous location
    GridLocation oldLoc = new GridLocation(player1Row, player1Col);
    currentGrid.clearTileSprite(oldLoc);

    //change the field for player1Col
    player1Col--;
  }
}

//Known Processing method that automatically will run when a mouse click triggers it
 public void mouseClicked(){
  
  //check if click was successful
  System.out.println("Mouse was clicked at (" + mouseX + "," + mouseY + ")");
  if(currentGrid != null){
    System.out.println("Grid location: " + currentGrid.getGridLocation());
  }

  //what to do if clicked?
  GridLocation clickedLoc= currentGrid.getGridLocation();
  GridLocation player1Loc= new GridLocation(player1Row,player1Col);

  //check if the lcoations are within 1
  if(clickedLoc.equals(player1Loc)){

    //check if any nearby tiles hold any marks --> return the String
    player1Col--;
  }


    //check if the click is near the player
    if(isClickNearPlayer(clickedLoc, player1Loc)){

      //is an object nearby
      //loop thru the 3x3 grid surrouding player
      int leftCol = player1Col -1;
      int rightCol = player1Col +1;
      int topRow = player1Row -1;
      int bottomRow = player1Row + 1;

      for(int r=topRow; r<=bottomRow; r++ ){
        for(int c=leftCol; c<=rightCol; c++){

          GridLocation loc = new GridLocation(r,c);
          
          //if item is found
          if(currentGrid.hasMark(loc)){

            String tempMark= currentGrid.getMark(loc);

          
            //if hairclip item
            if( tempMark.equals("hairclip") ){
              
              //add item to array
              items.add(tempMark);
              
              // image of item of disapeers
              currentGrid.removeMark(loc);
              currentGrid.clearTileImage(loc);
            }

            //if drawer item
            else if( tempMark.equals("drawer") ){
              
              //change to key
              currentGrid.setMark("key", loc);
              //System.out.println("SetMark called with: " + loc);

              // change image to a key
              currentGrid.setTileImage(loc,key);

            }

                
            //if key item
            else if( tempMark.equals("key") ){
              
              //add item to array
              items.add(tempMark);
              println("KEY ITEM HELD");
            
              // image of item of disapeers
              currentGrid.removeMark(loc);
              currentGrid.clearTileImage(loc);
            }

            //if knight item
          else if( tempMark.equals("Knight") ){
            
            //add item to array
            //items.add(tempMark);
            
            //image of item of disapeers
            currentGrid.removeMark(loc);
            currentGrid.clearTileImage(loc);
            currentScreen.setBg(basementBg);
          }

          else if( tempMark.equals("fingerprint") ){
            
            //add item to array
            items.add(tempMark);
            
            // image of item of disapeers
            currentGrid.removeMark(loc);
            currentGrid.clearTileImage(loc);
          }

          else if( tempMark.equals("hairstrand") ){
            
            //add item to array
            items.add(tempMark);
            
            // image of item of disapeers
            currentGrid.removeMark(loc);
            currentGrid.clearTileImage(loc);
          }

        }
      } //close 2nd for loop

    }
  }
  

  //Toggle the animation on & off
  doAnimation = !doAnimation;
  System.out.println("doAnimation: " + doAnimation);

    
} //close mouseClicked()

public boolean isClickNearPlayer(GridLocation clickedLoc, GridLocation player1Loc){

  return true;
}





//------------------ CUSTOM  METHODS --------------------//

public void itemSetup1(){

  GridLocation haircliploc = new GridLocation(10, 2);
  mainGrid.setTileImage(haircliploc, hairclip);

  //Display key
  GridLocation drawerloc = new GridLocation(5, 2);
  mainGrid.setTileImage(drawerloc, drawer);

  GridLocation tvloc = new GridLocation (15, 15);
  mainGrid.setTileImage(tvloc, tv);

  GridLocation knightloc = new GridLocation(14, 9);
  mainGrid.setTileImage(knightloc, knight);

  GridLocation fploc = new GridLocation(13, 5);
  mainGrid.setTileImage(fploc, fingerprint);

  GridLocation hairstrandloc = new GridLocation(8, 14);
  mainGrid.setTileImage(hairstrandloc, hairstrand);

  //set marks
  System.out.println(currentGrid.setNewMark("drawer", drawerloc));
  System.out.println(currentGrid.setNewMark("hairclip", haircliploc));
  System.out.println(currentGrid.setNewMark("tv", tvloc));
  System.out.println(currentGrid.setNewMark("Knight", knightloc));
  System.out.println(currentGrid.setNewMark("fingerprint", fploc));
  System.out.println(currentGrid.setNewMark("hairstrand", hairstrandloc));


  //marks.add(0,"key");
  

}

//method to update the Title Bar of the Game
public void updateTitleBar(){

  if(!isGameOver()) {
    //set the title each loop
    surface.setTitle(titleText + "    " + extraText);

    //adjust the extra text as desired
  
  }

}

//method to update what is drawn on the screen each frame
public void updateScreen(){
  
  //Update the Background
  background(currentScreen.getBg());

  //splashScreen update
  if(splashScreen.getScreenTime() > 3000 && splashScreen.getScreenTime() < 5000){
    currentScreen = mainGrid;
  
  //Inventory panel
  } else {

    String inventoryText = "";
    //loop through inventory
    for( String item : items){
      inventoryText += item;
    }
    textBox("Inventory: " + inventoryText);

  }

  //mainGrid Screen Updates
  if(currentScreen == mainGrid){
    currentGrid = mainGrid;

    //Display the Player1 image
    // GridLocation player1Loc = new GridLocation(player1Row,player1Col);
    // currentGrid.setTileImage(player1Loc, player1);

    GridLocation p1Loc= new GridLocation(player1Row,player1Col);
    currentGrid.setTileSprite(p1Loc, p1);

    //Update other screen elements
    currentGrid.showImages();
    currentGrid.showSprites();
    currentGrid.showGridSprites();
  }

  //update other screens?

}

//Method to populate enemies or other sprites on the screen
public void populateSprites(){

  //What is the index for the last column?
  int lastCol = currentGrid.getNumCols()-1;

  //Loop through all the rows in the last column
  for(int r=0; r<currentGrid.getNumRows(); r++){

    //Generate a random number
    double rando = Math.random();

    //10% of the time, decide to add an image to a Tile
    if(rando < 0.1f){
      //currentGrid.setTileImage(new GridLocation(r,lastCol), enemy);
      //System.out.println("Populating in row " + r);
      currentGrid.setTileSprite(new GridLocation(r, lastCol), enemySprite);
    }

  }


}

//Method to move around the enemies/sprites on the screen
public void moveSprites(){

  //Loop through all of the cells in the grid
  for (int r = 0; r < currentGrid.getNumRows(); r++) {
    for (int c = 1; c < currentGrid.getNumCols(); c++) {

      //Store the 2 locations to move
      GridLocation loc = new GridLocation(r, c);
      GridLocation newLoc = new GridLocation(r, c - 1);
      
      // Check if the current tile has an image and is NOT the player1
      // if(currentGrid.hasTileImage(loc) && !currentGrid.getTileImage(loc).equals(player1) ){
      if(currentGrid.hasTileSprite(loc) ){
        //System.out.println("Moving sprite found at loc " + loc);

        //Get image from current location
        //PImage img = currentGrid.getTileImage(loc);
        AnimatedSprite sprite = currentGrid.getTileSprite(loc);

        //Set image to new Location 
        //currentGrid.setTileImage(newLoc, img);
        //System.out.println("Moving to newLoc" + newLoc);
        currentGrid.setTileSprite(newLoc, sprite);

        //Erase image from old location
        //currentGrid.clearTileImage(loc);
        currentGrid.clearTileSprite(loc);

        //System.out.println(loc + " " + currentGrid.hasTileImage(loc));
      }

      //What is at the first column?
      if (c == 1) {
        currentGrid.clearTileImage(newLoc);
        currentGrid.clearTileSprite(newLoc);
      }

    }
  }
}

//Method to handle the collisions between Sprites on the Screen

//it checks collisions - requires two parameters
public boolean checkCollision(GridLocation current, GridLocation newLoc){
  

//get image at current location first, if any
PImage image = currentGrid.getTileImage(current);

//if nothing is there, there can't be a collision
if(image == null){
  return false;
}

//get image at new location, if any
PImage newImage = currentGrid.getTileImage(newLoc);
Sprite sprite = currentGrid.getTileSprite(newLoc);

//if nothing is at new location, there can't be a collision 
if(newImage == null){
  return false;
}

//check if player interacts with item or npc
// if(player1.equals(image) && key.equals(newImage)){
if(p1.equals(sprite) && key.equals(newImage)){
    currentGrid.clearTileSprite(current);
}

return true;


}

public void handleCollisions(){


}

//method to indicate when the main game is over
public boolean isGameOver(){ 
  return false; //by default, the game is never over
}

//method to describe what happens after the game is over
public void endGame(){
    System.out.println("Game Over!");

    //Update the title bar

    //Show any end imagery
    // image(endScreen, 100,100);
    currentScreen = endScreen;

}



public void playerAnimationSetup(){  
  
  p1 = new AnimatedSprite(p1File, p1json);
  p1.resize(50,80);
  p1.animate(1.0f);
  GridLocation p1Loc= new GridLocation(player1Row,player1Col);
  currentGrid.setTileSprite(p1Loc, p1);

}


// //example method that creates 5 horses along the screen
// public void exampleAnimationSetup(){  
//   int i = 2;
//   exampleSprite = new AnimatedSprite("sprites/horse_run.png", "sprites/horse_run.json");
// }



// //example method that animates the horse Sprites
// public void checkExampleAnimation(){
//   if(doAnimation){
//     exampleSprite.animateVertical(5.0, 1.0, true);
//   }
// }



public void textBox(String message){
  this.textBox(message, color(204,102,0), color(153));
}

public void textBox(String message, int boxClr, int textClr){
  
  float boxWidth = width;
  float boxHeight = 100; 
  float leftSide = 0;
  float topSide = height-boxHeight;
  int textHeight = 40;
 
  fill(boxClr);
  rect(leftSide, topSide, boxWidth, boxHeight, 10);
  textSize(textHeight);
  fill(153);
  //fill(textClr);
  text(message, 40, height - ((boxHeight-textHeight)/2)); 


}

/*
private void showBox (final String sporocilo)
{
  final PFont fontek = loadFont("ArialTest.vlw");  
     
  //Izracunamo x in y pozicijo (okno se pojavi na sredini klicujocega okna) ter nastavimo visino in sirino okna
  Rectangle r = frame.getBounds();
  final int visina = 150;
  final int sirina = 400;
  final int x = r.x+r.width/2-sirina/2;
  final int y = r.y+r.height/2-visina/2;
  
      
  ControlP5 boxControl = new ControlP5(this);
  boxControl.setAutoDraw(true);
  ControlWindow boxWindow = boxControl.addControlWindow("boxWindow", x, y, sirina,visina);
  boxWindow.setTitle("Sporocilo");
  boxWindow.hideCoordinates();
  boxWindow.setBackground(color(#6386c4));

  
    
  Textlabel boxLabel = boxControl.addTextlabel("boxLabel", sporocilo, 10,10);

  boxLabel.setWidth(350);
  boxLabel.moveTo(boxWindow);
  boxLabel.setPosition(10,30);
   
   
  boxControl.setColorActive(#79FFB8);
  boxControl.setColorForeground(#a8e6c6);

  Button gumb = boxControl.addButton("OK_message",0,160,100,80,25);
  gumb.captionLabel().set("OK");
  gumb.captionLabel().style().marginLeft = 27;
  gumb.moveTo(boxWindow);


  boxControl.setControlFont(fontek);

   
   
}
*/



/* Animated Sprite class - useful to have Sprites move around
 * Designed to be used with Spritesheets & JSON Array files from TexturePacker software: 
 * https://free-tex-packer.com/app/
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial: https://youtu.be/3noMeuufLZY
 * Authors: Joel Bianchi, Aiden Sing, Tahlei Richardson
 * Last Edit: 6/5/2023
 * Edited jsonFile renamed to jsonFile
 * Revised Variable to track animation speed
 * Sprite Copying
 */
 
public class AnimatedSprite extends Sprite{
  
    private String pngFile;
    private String jsonFile;
    private ArrayList<PImage> animation;
    private int len;
    private float iBucket;
    private float aSpeed; //variable to track how quickly the animation images cycle

    JSONObject spriteData;
    PImage spriteSheet;

  // Constructor #1 for AnimatedSprite with Spritesheet (Must use the TexturePacker to make the JSON)
  public AnimatedSprite(String png, String json, float x, float y, float aSpeed) {
    super(png, x, y, 1.0f, true);
    
    this.jsonFile = json;
    this.pngFile = png;
    this.animation = convertPngToList(png);
    super.setW(this.animation.get(0).width);
    super.setH(this.animation.get(0).height);
    super.setLeft(x);
    super.setTop(y);
    //System.out.println("AS w: " + super.getW() + ",h: " + super.getH());

  }

  //Constructor #2: animations + starting coordinates
  public AnimatedSprite(String png, String json, float x, float y ) {
    this(png, json, x, y, 1.0f);
  }

  // Constructor #3 taking in images and json only
  public AnimatedSprite(String png, String json) {
    this(png, 0.0f, 0.0f, json);
  }

  // Legacy Constructor for 2022 version
  public AnimatedSprite(String png, float x, float y, String json) {
    this(png, json, x, y);
  }


  //Overriden method: Displays the correct frame of the Sprite image on the screen
  public void show() {
    int index = (int) Math.floor(Math.abs(this.iBucket)) % this.len;
    image(animation.get(index), super.getLeft(), super.getTop());
    //System.out.println("aSpeed: "+ aSpeed+"\tib: "+iBucket+"\t ind: "+ index);
    //System.out.println("Pos: "+ super.getX() +"," + super.getY());
  } 

  //Method to cycle through the images of the animated sprite & reset a new animation speed
  public void animate(float animationSpeed){
    this.aSpeed = animationSpeed;
    animate();
  }

  //Method to cycle through the images of the animated sprite
  public void animate(){
    iBucket += aSpeed/this.len;
    show();
  }

  //Method that makes animated sprite move in any straight line + sets animation speed
  public void animateMove(float hSpeed, float vSpeed, float animationSpeed, boolean wraparound){
    this.aSpeed = animationSpeed;
    animateMove(hSpeed, vSpeed, wraparound);
  }
  
  //Method that makes animated sprite move in any straight line
  public void animateMove(float hSpeed, float vSpeed, boolean wraparound){
    
    //adjust speed & frames
    animate();
    super.move( (int) (hSpeed * 10), (int) (vSpeed * 10) );
  
    //wraparound sprite if goes off the right or left
    if(wraparound){
      wraparoundHorizontal();
      wraparoundVertical();
    }
  }

  //animated method that makes the Sprite move to the right-left
  public void animateHorizontal(float horizontalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(horizontalSpeed, 0, animationSpeed, wraparound);
  }

  //animated method that makes the Sprite move down-up
  public void animateVertical(float verticalSpeed, float animationSpeed, boolean wraparound) {
    animateMove(0, verticalSpeed, animationSpeed, wraparound);
  }

  //NIKO + JAIDEN
  public void animateToPlayer(AnimatedSprite player, float animationSpeed, boolean wraparound) {
    float xDifference = player.getCenterX() - this.getCenterX();
    float yDifference = player.getCenterY() - this.getCenterY();
    if ((xDifference < 100 && xDifference > -100) && (yDifference < 150 && yDifference > -150)) {
      animateMove(xDifference/300.0f, yDifference/300.0f, animationSpeed, wraparound);
    }
    animateMove(xDifference/1000.0f, yDifference/1000.0f, animationSpeed, wraparound);
  }

  //Accessor method for the JSON path
  public String getJsonFile(){
    return this.jsonFile;
  }
  
  //Mutator method for the speed of the animation -Aiden Sing & Tahlei Richardson, 2023
  public void setAnimationSpeed(float aSpeed) {
    this.aSpeed = aSpeed;
  }

  //Method to resize the animated sprite images to different dimensions
  public void resize(int x, int y){
    for(int i=0; i<animation.size(); i++){
      PImage pi = animation.get(i);
      pi.resize(x,y);
    }
  }

  //Method to copy an AnimatedSprite
  public AnimatedSprite copy(){
    //super.copy();
    return new AnimatedSprite(this.pngFile, this.jsonFile, super.getLeft(), super.getTop(), this.aSpeed);
  }
  
  //Method to copy an AnimatedSprite to a specific location
  public AnimatedSprite copyTo(float x, float y){
    //super.copy();
    return new AnimatedSprite(this.pngFile, this.jsonFile, x, y, this.aSpeed);
  }
  

  //---------------------PRIVATE HELPER METHODS--------------------------//

  //wraparound sprite if goes off the right-left
  private void wraparoundHorizontal(){
    if ( super.getLeft() > width ) {
      super.setLeft( -super.getW() );
    } else if ( super.getRight() < -width ){
      super.setRight( width );
    }
  }

  //wraparound sprite if goes off the top-bottom
  private void wraparoundVertical(){
    if ( super.getTop() > height ) {
      super.setTop( -super.getH() );
    } else if ( super.getBottom() < -height ){
      super.setBottom( height );
    }
  }

  private ArrayList<PImage> convertPngToList(String png){

      ArrayList<PImage> ani = new ArrayList<PImage>();
      spriteData = loadJSONObject(jsonFile);
      spriteSheet = loadImage(png);
      JSONArray frames = spriteData.getJSONArray("frames");
      
      System.out.println("Loading Animated Sprite...");
      for(int i=0; i<frames.size(); i++){

        JSONObject frame = frames.getJSONObject(i);
        //System.out.println(i + ": " + frame + "\n");
        JSONObject fr = frame.getJSONObject("frame");
        //System.out.println("ss: " + fr + "\n");

        int sX = fr.getInt("x");
        int sY = fr.getInt("y");
        int sW = fr.getInt("w");
        int sH = fr.getInt("h");
        System.out.println(i + ":\t sX:" + sX + ":\t sY:" + sY + ":\t sW:" + sW + ":\t sH:" + sH);
        PImage img = spriteSheet.get(sX, sY, sW, sH);
        ani.add(img);

        this.len = ani.size();
        this.iBucket = 0.0f;
        this.aSpeed = aSpeed;
      }

      return ani;

    }


}
/* Grid Class - Used for rectangular-tiled games
 * A 2D array of GridTiles which can be marked
 * Author: Joel Bianchi
 * Last Edit: 6/6/2023
 * Edited to show all Images & Sprites
 * Made a subclass of World
 * Ability to remove marks -RJ
 */

public class Grid extends World{
  
  private int rows;
  private int cols;
  private GridTile[][] board;
  

  //Grid constructor #1
  public Grid(String screenName, PImage bg, int rows, int cols){
    super(screenName, bg);

    this.rows = rows;
    this.cols = cols;
    board = new GridTile[rows][cols];
    
    for(int r=0; r<rows; r++){
      for(int c=0; c<cols; c++){
        board[r][c] = new GridTile(new GridLocation(r,c));
      }
    }
  }

  //Grid Construtor #2: Only accepts the number of rows & columns (Default for 2023)
  public Grid(int rows, int cols){
    this("grid",null, rows, cols);
  }

  // Grid Constructor #3: Default constructor that creates a 3x3 Grid  
  public Grid(){
     this(3,3);
  }

 
  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.
  public void setMark(String mark, GridLocation loc){
    board[loc.getRow()][loc.getCol()].setMark(mark);
    printGrid();
  } 
  
  //Method to get the mark value at a location -RJ Morel
  public String getMark(GridLocation loc){
    return board[loc.getRow()][loc.getCol()].getMark();
  }
  
  //Method to get the mark value at a location -RJ Morel
  public boolean removeMark(GridLocation loc){
    boolean isGoodClick = board[loc.getRow()][loc.getCol()].removeMark();
    return isGoodClick;
  }
  
  //Method to check if a location has a mark -RJ Morel
  public boolean hasMark(GridLocation loc){
    GridTile tile = board[loc.getRow()][loc.getCol()];
    boolean isGoodClick = tile.getMark() != tile.getNoMark();
    return isGoodClick;
  } 

  // Method that Assigns a String mark to a location in the Grid.  
  // This mark is not necessarily visible, but can help in tracking
  // what you want recorded at each GridLocation.  
  // Returns true if mark is correctly set (no previous mark) or false if not
  public boolean setNewMark(String mark, GridLocation loc){
    int row = loc.getRow();
    int col = loc.getCol();
    boolean isGoodClick = board[row][col].setNewMark(mark);
    printGrid();
    return isGoodClick;
  } 
  
  //Method that prints out the marks in the Grid to the console
  public void printGrid(){
   
    for(int r = 0; r<rows; r++){
      for(int c = 0; c<cols; c++){
         System.out.print(board[r][c]);
      }
      System.out.println();
    } 
  }
  
  //Method that returns the GridLocation of where the mouse is currently hovering over
  public GridLocation getGridLocation(){
      
    int row = mouseY/(pixelHeight/this.rows);
    int col = mouseX/(pixelWidth/this.cols);

    return new GridLocation(row, col);
  } 

  //Accessor method that provide the x-pixel value given a GridLocation loc
  public int getX(GridLocation loc){
    int widthOfOneTile = pixelWidth/this.cols;
    //calculate the left of the grid GridLocation
    int pixelX = (widthOfOneTile * loc.getCol()); 
    return pixelX;
  }
  public int getX(int row, int col){
    return getX(new GridLocation(row, col));
  }
  
  //Accessor method that provide the y-pixel value given a GridLocation loc
  public int getY(GridLocation loc){
    int heightOfOneTile = pixelHeight/this.rows;
    //calculate the top of the grid GridLocation
    int pixelY = (heightOfOneTile * loc.getRow()); 
    return pixelY;
  }
  public int getY(int row, int col){
    return getY(new GridLocation(row,col));
  }

  
  //Accessor method that returns the number of rows in the Grid
  public int getNumRows(){
    return rows;
  }
  
  //Accessor method that returns the number of cols in the Grid
  public int getNumCols(){
    return cols;
  }

  //Accessor method that returns the width of 1 Tile in the Grid
  public int getTileWidthPixels(){
    return pixelWidth/this.cols;
  }
  //Accessor method that returns the height of 1 Tile in the Grid
  public int getTileHeightPixels(){
    return pixelHeight/this.rows;
  }


  //Returns the GridTile object stored at a specified GridLocation
  public GridTile getTile(GridLocation loc){
    return board[loc.getRow()][loc.getCol()];
  }

  //Returns the GridTile object stored at a specified row and column
  public GridTile getTile(int r, int c){
    return board[r][c];
  }

  //------------------PImage Methods ---------------//
  //Method that sets the image at a particular tile in the grid & displays it
  public void setTileImage(GridLocation loc, PImage pi){
    GridTile tile = getTile(loc);
    tile.setImage(pi);
    showTileImage(loc);
  }

  //Method that returns the PImage associated with a particular Tile
  public PImage getTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.getImage();
  }


  //Method that returns if a Tile has a PImage
  public boolean hasTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasImage();
  }

  //Method that clears the tile image
  public void clearTileImage(GridLocation loc){
    setTileImage(loc,null);
  }

  public void showTileImage(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasImage()){
      image(tile.getImage(),getX(loc),getY(loc));
    }
  }

  //Method to show all the PImages stored in each GridTile
  public void showImages(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileImage(tempLoc)){
            showTileImage(tempLoc);
          }
        }
      }
  }

  //------------------AnimatedSprite Methods ---------------//
  //Method that sets the Sprite at a particular tile in the grid & displays it
  public void setTileSprite(GridLocation loc, AnimatedSprite sprite){
    GridTile tile = getTile(loc);
    if(sprite == null){
      tile.setSprite(null);
      //System.out.println("Cleared tile @ " + loc);
      return;
    }
    sprite.setLeft(getX(loc));
    sprite.setTop(getY(loc));
    tile.setSprite(sprite);
    showTileSprite(loc);
    //System.out.println("Succcessfully set tile @ " + loc);
  }
  
  //Method that returns the PImage associated with a particular Tile
  public AnimatedSprite getTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    //System.out.println("Grid.getTileSprite() " + tile.getSprite());
    return tile.getSprite();
  }
  
  //Method that returns if a Tile has a PImage
  public boolean hasTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    return tile.hasSprite();
  }

  //Method that clears the tile image
  public void clearTileSprite(GridLocation loc){
    setTileSprite(loc,null);
  }

  public void showTileSprite(GridLocation loc){
    GridTile tile = getTile(loc);
    if(tile.hasSprite()){
      tile.getSprite().animate();
    }
  }

  
  //Method to show all the PImages stored in each GridTile
  public void showGridSprites(){

    //Loop through all the Tiles and display its images/sprites
      for(int r=0; r<getNumRows(); r++){
        for(int c=0; c<getNumCols(); c++){

          //Store temporary GridLocation
          GridLocation tempLoc = new GridLocation(r,c);
          
          //Check if the tile has an image
          if(hasTileSprite(tempLoc)){
            setTileSprite(tempLoc, getTileSprite(tempLoc));
            //showTileSprite(tempLoc);
          }
        }
      }
  }

  //Method to clear the screen from all Images & Sprites
    public void clearGrid(){

      //Loop through all the Tiles and display its images/sprites
        for(int r=0; r<getNumRows(); r++){
          for(int c=0; c<getNumCols(); c++){

            //Store temporary GridLocation
            GridLocation tempLoc = new GridLocation(r,c);
            
            //Check if the tile has an image
            if(hasTileSprite(tempLoc)){
              setTileSprite(tempLoc, getTileSprite(tempLoc));
              //showTileSprite(tempLoc);
            }
          }
        }
    }




}
/* GridLocation class - helper class to store coordinates more easily
 * Author: Joel Bianchi
 * Last Edit: 5/22/2023
 * Added .equals() method, Renamed getRow() & getCol()
 */

public class GridLocation{
 
  int row;
  int col;
  
  public GridLocation(int row, int col){
    this.row = row;
    this.col = col;
  }
  
  public int getRow(){
    return row;
  }
  
  public int getCol(){
    return col;
  }
  
  public String toString(){
    return row + "," + col;
  }
  
  public int getYCoord() {
    return row;
  }
  
  public int getXCoord() {
    return col;
  }

  public boolean equals(GridLocation otherLoc){
    if(getRow() == otherLoc.getRow() && getCol() == otherLoc.getCol()){
      return true;
    }
    return false;

  }
 
}
/* GridTile class - Designed to be used within the Grid class
 * GridTiles have distinguishable marks that will be printed out to the console for easy visualization of a 2D array
 * GridTiles can indicate if they have been "captured", colored, or are displaying an image
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 6/6/2023
 * Edited to be superclass of HexTile, included hasImage() function
 */



public class GridTile{
  
  private GridLocation location;
  private PImage pi;
  private AnimatedSprite sprite;
  private boolean coveredPic;
  private int fillColor;
  final int defaultFillColor = 0xFFFFFFFF; //WHITE
  private int outlineColor;
  final int defaultOutlineColor = 0xFF000000; //BLACK
  private String mark;
  final private static String noMark = ".";
  private boolean isCaptured;

  //------------------GridTile Constructors ---------------//
  //GridTile constructor #1: Adds the specified String mark
  public GridTile(String mark, GridLocation loc){
    this.mark = mark;
    location = loc;
    fillColor = defaultFillColor;
    outlineColor = defaultOutlineColor;
    coveredPic = false;
  }
  
  //GridTile constructor #2 which adds a mark, but no Location
  public GridTile(String mark){
    this(mark, null);
  }

  //GridTile constructor #3 which adds a GridLocation, but no mark  
  public GridTile(GridLocation loc){
    this(noMark, loc);
  }

  //Default GridTile constructor which puts an empty String mark in the GridTile
  public GridTile(){
    this(noMark, null);
  }

  //------------------Marking Methods ---------------//
  // Accessor method that gets the mark in the GridTile
  public String getMark(){
    return mark;
  }

  //Method to access the symbol for no mark
  public String getNoMark(){
    return noMark;
  }
  
  // Mutator method that automatically changes the mark
  public void setMark(String mark){
    this.mark = mark;
  }

  // Mutator method sets a new mark in the GridTile 
  // if it does not already have a mark, 
  // returns true or false if successful
  public boolean setNewMark(String mark){
    if(this.mark.equals(noMark)){
      this.mark = mark;
      System.out.println("Successfully changed mark");
      return true;
    } else {
      System.out.println("That GridTile is already taken!");
      return false;
    }
  }

  public boolean removeMark(){
    if(this.mark.equals(noMark)){
      return false;
    }
    else{
      this.mark = noMark;
      return true;
    }
  }
  
  //------------------PImage Methods ---------------//
  // Mutator method that sets a new PImage in the GridTile
  public void setImage(PImage pi){
    this.pi = pi;
  }

  //Accessor method that returns the PImage stored in the GridTile
  public PImage getImage(){
    return pi;
  }

  //Method to check if the GridTile has an PImage in it
  public boolean hasImage(){
    if(pi == null){
      return false;
    }
    return true;
  }

  //------------------Sprite Methods ---------------//
 // Mutator method that sets a new AnimatedSprite in the GridTile
  public void setSprite(AnimatedSprite sprite){
    this.sprite = sprite;
  }

  //Accessor method that returns the AnimatedSprite stored in the GridTile
  public AnimatedSprite getSprite(){
    return sprite;
  }

  //Method to check if the GridTile has an AnimatedSprite in it
  public boolean hasSprite(){
    if(sprite == null){
      return false;
    }
    return true;
  }

  //------------------Capturing Tiles Methods ---------------//
  //method to "capture" a tile by changing its color
  public void captureTile(int clr){
    this.isCaptured = false;
    this.fillColor = clr;
  }

  //method to "release" a tile by changing its color
  public void releaseTile(){
    this.isCaptured = false;
    this.fillColor = defaultFillColor;
  }

  //accessor method to check if tile is captured
  public boolean checkIsCaptured(){
    return isCaptured;
  }


  //------------------Coloring Tiles Methods ---------------//
  //method to change the color of the tile
  public void setColor(int clr) {
    this.fillColor = clr;
  }

  //method to access the color of the tile
  public int getColor() {
    return fillColor;
  }

  public void setOutlineColor(int oclr){
    this.outlineColor = oclr;
  }

  public int getOutlineColor(){
    return this.outlineColor;
  }

  public void setCoveredWithPic(boolean isCoveredWithPic) {
    this.coveredPic = isCoveredWithPic;
  }

  public boolean isCoveredWithPic() {
    return this.coveredPic;
  }



  //method to access the location of the GridTile
  public GridLocation getLocation(){
      return location;
  }

  //ToString simply retuns the mark on the Tile, useful for printing out 2D grids
  public String toString(){
    return mark;
  }


}
/* HexGrid Class - useful for tile-based games with more flavor!
 * Inspired from CSRessel's Catan Game & Emmanuel Suriel's Grid class
 * https://github.com/CSRessel/catan/blob/master/src/gui/CatanBoard.java
 * Adapted for Processing
 * Authors: Joel Bianchi, Naomi Gaylor, Ezzeldin Moussa
 * Last Edit: 5/31/2023
 * NOT FULLY FUNCTIONAL YET
 */





public class HexGrid {

	ArrayList<HexLocation> allHexLocations;
	ArrayList<HexLocation> unclaimedLocations;
	
    private HexTile[][] map;
    private int defaultOutlineColor = 0xFFFFFFFF;	//WHITE
    private int defaultFillColor = 0xFF000000; 		//BLACK
	private int defaultBgColor = color(164,200,218);
	
	private boolean bgSet = false;

    //GUI fields
	private int hexGen;
	private int hexDiameter;
	private int boardHeight;
	private int hexagonSide;
	private int heightMargin = 100;
	private int widthMargin;
	private final double sqrt3div2 = 0.86602540378f;

    //HexGrid Constructor
    public HexGrid(int hexGen){

		this.hexGen = hexGen;

		//Generate all the valid hexLocations
		allHexLocations = new ArrayList<HexLocation>();
        
		hexDiameter = hexGen *2 -1;	//originally 5
		int midHex = hexGen;	//originally 3
		System.out.println("mid:" + midHex);

		//Create top half of HexLocations
		for(int r=1; r <= midHex; r++){
			for(int c=1; c <= midHex + r - 1; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		//Create bottom half of HexLocations
		for(int r = midHex +1; r <= hexDiameter; r++){
			for(int c= r-midHex + 1; c <= hexDiameter; c++){
				allHexLocations.add( new HexLocation(c,r) );
			}
		}
		
		System.out.println("All generated HexLocations:");
		System.out.println(allHexLocations);

		//Construct 2D array of HexTiles
		int row = hexDiameter + 2;
		int col = row;
        map = new HexTile[row][col];

		//Initialize unclaimed HexLocations arrayList
		unclaimedLocations = new ArrayList<HexLocation>();

		for(HexLocation loc: allHexLocations){

			//Generate hexTiles for each HexLocation
			HexTile hTile = new HexTile(loc, this.hexDiameter);
			map[loc.getYCoord()][loc.getXCoord()] = hTile;
			hTile.setColor(defaultFillColor);
			hTile.setOutlineColor(defaultOutlineColor);
			setHexTileCenterPixels(hTile);
			setHexTilePoly(hTile);

			//Generate unclaimedTiles ArrayList
			unclaimedLocations.add(loc);
		}
    }

	public boolean isValidLocation(HexLocation testLoc){
		for(int i=0; i<unclaimedLocations.size(); i++){
			if(unclaimedLocations.get(i).equals(testLoc)){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinOne(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+1 || endX==startX-1 || endX==startX){
			if(endY==startY+1 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public boolean isWithinTwo(HexLocation start, HexLocation end){
		int startX = start.getXCoord();
		int startY = start.getYCoord();
		int endX = end.getXCoord();
		int endY = end.getYCoord();

		if(endX==startX+2 || endX==startX+1 || endX==startX-2 || endX==startX-1 || endX==startX){
			if(endY==startY+2 || endY==startY+1 || endY==startY-2 || endY==startY-1 || endY==startY){
				return true;
			}
		}
		return false;
	}

	public void removeHexLocation(HexLocation loc){
		for(int i=0; i<unclaimedLocations.size(); i++){
      		if(unclaimedLocations.get(i).equals(loc)){
        		unclaimedLocations.remove(i);
				return;
			}
		}
		System.out.println("Error when trying to remove Location: " + loc);
	}


	public void displayHexGrid(){

        int mapHeight = map.length;
        //int hexagonSide = 50;
		//int hexagonSide = (mapHeight - 2 * heightMargin) / 8;
        int widthMargin = (width - (int) (10 * hexagonSide * sqrt3div2)) / 2;

        // Graphics2D g2 = (Graphics2D)g;
        // g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        // g.setFont(new Font("TimesRoman", Font.PLAIN, 20));
        // super.paintComponent(g2);

		//System.out.println("ahl size: " + allHexLocations.size());

		//Fill in each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			//System.out.println(hTile);
			fillOneHex(hTile);
		}

		//Outline each Hex
		for(HexLocation loc: allHexLocations){
			int x = loc.getXCoord();
			int y = loc.getYCoord();
			HexTile hTile = map[x][y];
			outlineOneHex(hTile);
		}

		//System.out.println("HexLocations: " + hexLocations);
    }

	private void setHexTileCenterPixels(HexTile hTile){
		int x = hTile.getLocation().getXCoord();
        int y = hTile.getLocation().getYCoord();
		Point centerPixels = findTileCenter(hTile);
		hTile.setHexCenterPixels(centerPixels);
	}

	private void setHexTilePoly(HexTile hTile){
        Polygon hexPoly = makeHex(hTile.getCenterPixels());
		hTile.setHexPoly(hexPoly);
	}

	//method to fill in 1 hex tile
    public void fillOneHex(HexTile hTile){

        boolean hasImage = hTile.hasImage();
		//System.out.println("drawHex: x:"+tile.getLocation().getXCoord()+",y:"+tile.getLocation().getYCoord());
		
        //FILL IN SOLID COLOR - fill in hexTile with a solid color if no picture
        if(!hasImage){
			int fillClr = hTile.getColor();
			
			// ???

		}
    		
        //FILL IN PICTURE
        if(hasImage){    
			PImage photo = hTile.getImage();
			
			try{
				//resize the image to fit in the hex
				int iSize = (int) (hexagonSide * 1.25f);
				photo.resize(iSize, iSize);

				//mask the image to the hex shape
				PGraphics maskImage;
				maskImage = createGraphics(iSize,iSize);
				maskImage.beginDraw();
				//maskImage.triangle(30, 480, 256, 30, 480, 480);
				//maskImage = drawOneHex(PGraphics maskImage);
				maskImage.endDraw();
				
				// apply mask
				photo.mask(maskImage);

				//display masked image
				image(photo, 0, 0);

				final int ix = getImageX(hTile, photo);
				final int iy = getImageY(hTile, photo);
				
				//System.out.println("Img: " + locImageName);
				//System.out.println("nPoints:" + poly.npoints);
				//System.out.println("ix:" + ix + "\tiy:"+iy);

				//System.out.println("Drew image for x:" + x + ",y:" + y);

			} catch(Exception e){

			} //end catch
		} //end image fill
	} //end drawing one hex

	//method to draw the outline around a hex tile
    public void outlineOneHex(HexTile hTile){
		int oClr = hTile.defaultOutlineColor;
		float stroke = 3.0f;
		int tileOutlineColor = hTile.getOutlineColor();
		
		if(tileOutlineColor != oClr){
			PGraphics pg = getHexPGraphics(hTile);

			//DRAW THE OUTLINE!???

		}
	}


//---------------------- HELPER METHODS -------------------------------//
    private int getImageX(HexTile hTile, PImage image){
    	Point center = findTileCenter(hTile);
        int imageWidth =  image.width;
        return center.x - imageWidth/2; 
    }
    private int getImageY(HexTile hTile, PImage image){        
        Point center = findTileCenter(hTile);
        int imageHeight =  image.height;
        return center.y - imageHeight/2; 
    }

	//method finds the center pixels of a HexTile based on its grid coordinates
	private Point findTileCenter(HexTile hTile){
		return findTileCenter(hTile.getLocation().getXCoord(), hTile.getLocation().getYCoord());
	}
	private Point findTileCenter(int xcoord, int ycoord){
		int x = xcoord;
		int y = ycoord;
		//code for a bottom left origin with rows as x and cols as y
		// int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		// 		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		// 		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		// int yCenter = boardHeight - (heightMargin + hexagonSide
		// 		+ (int) ((y - 1) * hexagonSide * 1.5));

		//code for a top left origin (to mimic how Java 2D arrays are modeled) with rows as y and cols as x
		int xCenter = widthMargin + (int) (3 * hexagonSide * sqrt3div2)
		+ (int) ((x - 1) * 2 * hexagonSide * sqrt3div2)
		- (int) ((y - 1) * hexagonSide * sqrt3div2);
		
		int yCenter = (heightMargin + hexagonSide 
		+ (int) ((y - 1) * hexagonSide * 1.5f));

		return new Point(xCenter,yCenter);
	}



    //MUTATOR METHODS
    public void setAllTileColors(int tileColor){
        this.defaultFillColor = tileColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setColor(defaultFillColor);
                }
            }
        }
    }

	public void setAllTileOutlines(int outlineColor){
        this.defaultFillColor = outlineColor;
          for (int r = 0; r < map.length; r++) {
            for (int c = 0; c < map[0].length; c++) {
                if (map[r][c] != null){
                    map[r][c].setOutlineColor(defaultFillColor);
                }
            }
        }


    }


	//method to access any Hextile based on its location
    public HexTile getHexTile(HexLocation loc){
		int x = loc.getXCoord();
		int y = loc.getYCoord();
        return map[x][y];
    }

    public int setTileColor(HexLocation loc, int tileColor){
		HexTile hTile = getHexTile(loc);
        int oldColor = hTile.getColor();
        hTile.setColor(tileColor);
        return oldColor;
    }

	public void highlightTile(HexLocation loc) {
		HexTile hTile = getHexTile(loc);
		int highlightColor = 0xFFFFFFFF;

		Point p = hTile.getCenterPixels();

		//Shape shape = new Ellipse2D.Double((int)p.getX() - 25, (int)p.getY() - 25, 50, 50);

		// g2.setColor(Color.WHITE);
		// g2.fill(shape);
		// g2.draw(shape);
	}
    


    /* ---------------  HEX GRID ACCESSOR METHODS ------------------ */
	public HexTile[][] getMap(){
        return map;
    }
    
    public int getNumRows() {
		return map.length;
	}

	public int getNumCols() {
		return map[0].length;
	}

    //needs to be modified slightly because HexGrid doesn't include ALL tiles in the rectangle (like 0,0)
	public boolean isValid(final HexLocation loc) {
		final int row = loc.getYCoord();
		final int col = loc.getXCoord();
		return 0 <= row && row < getNumRows() && 0 <= col && col < getNumCols();
	}


    /* ---------------- BACKGROUND IMAGE METHODS ------------------------- */



	/**
	 * sets the background to imgName. The img is resized to fit in the grids
	 * dimensions. setColor() is disabled
	 * 
	 * @param imgName
	 */
	public void setBackground(PImage bgImage) {
		// this.xOffset = 0;
		// this.yOffset = 0;
		// this.xScale = 1.0;
		// this.yScale = 1.0;

		// backgroundImage = loadImage(imgName);
		// bgSet = true;

		//repaint();
	}

	/**
	 * Removes a regular background or moveable background, allowing setColor to
	 * work again.
	 */
	public void removeBackground() {
		bgSet = false;
	}



	public void setFillColor(final HexLocation loc, final int clr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set color of invalid location " + loc + " to color " + clr);
		map[loc.getXCoord()][loc.getYCoord()].setColor(clr);
		//repaint();
	}

	public int getFillColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get color from invalid location " + loc);
		return map[loc.getYCoord()][loc.getXCoord()].getColor();
	}

	// public void setImage(final HexLocation loc, final String imageFileName) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException(
	// 				"cannot set image for invalid location " + loc + " to \"" + imageFileName + "\"");
	// 	map[loc.getXCoord()][loc.getYCoord()].setImageFileName(imageFileName);
	// 	repaint();
	// }

	// public String getImage(final Location loc) {
	// 	if (!isValid(loc))
	// 		throw new RuntimeException("cannot get image for invalid location " + loc);
	// 	return map[loc.getYCoord()][loc.getXCoord()].getImageFileName();
	// }

	public void setTileOutlineColor(final HexLocation loc, final int oclr) {
		if (!isValid(loc))
			throw new RuntimeException("cannot set outline for invalid location " + loc);
            map[loc.getXCoord()][loc.getYCoord()].setOutlineColor(oclr);
		//repaint();
	}

	public int getTileOutlineColor(final HexLocation loc) {
		if (!isValid(loc))
			throw new RuntimeException("cannot get outline color for invalid location " + loc);
		return map[loc.getXCoord()][loc.getYCoord()].getOutlineColor();
	}

	public void setAllOutlinesColor(final int oclr) {
		for (int r = 0; r < getNumRows(); r++) {
			for (int c = 0; c < getNumCols(); c++) {
				map[r][c].setOutlineColor(oclr);
			}
		}
		//repaint();
	}



    /* ----- INPUT HANDLING -------------------------------------------------------------------- */
	// // returns -1 if no key pressed since last call.
	// // otherwise returns the code for the last key pressed.
	// public int checkLastKeyPressed() {
	// 	final int key = lastKeyPressed;
	// 	lastKeyPressed = -1;
	// 	return key;
	// }

	// // returns null if no location clicked since last call.
	// public HexLocation checkLastLocationClicked() {
	// 	final HexLocation loc = lastLocationClicked;
	// 	lastLocationClicked = null;
	// 	return loc;
	// }

	// public HexLocation waitForClick() {
	// 	while (true) {
	// 		final HexLocation clicked = this.checkLastLocationClicked();
	// 		if (clicked != null) {
	// 			//System.out.print("x:"+clicked.getXCoord()+ ",y:" + clicked.getYCoord());
	// 			return clicked;
	// 		} else {
	// 			//System.out.print("NOT CLICKED");
	// 			HexGrid.pause(100);
	// 		}
	// 	}
	// }

    // public static void pause(final int milliseconds) {
	// 	try {
	// 		Thread.sleep(milliseconds);
	// 	} catch (final Exception e) {
	// 		// ignore
	// 	}
	// }

    // public void keyPressed(final KeyEvent e) {
	// 	lastKeyPressed = e.getKeyCode();
	// }

	// public void mousePressed(final MouseEvent e) {

	// 	Point p = e.getPoint();
	// 	//System.out.println(p);
		
	// 	for(HexLocation loc : this.allHexLocations){
	// 		HexTile hTile = map[loc.getXCoord()][loc.getYCoord()];
	// 		Polygon hexPoly = hTile.getHexPoly();
	// 		if(hexPoly.contains(p)){
				
	// 			lastLocationClicked = loc;
				
	// 		}
	// 	}
	// }



    // ------------------ GUI HELPER METHODS --------------------------------------------------------------------------//

    // private void guiInit() {
    //     lastKeyPressed = -1;
    //     lastLocationClicked = null;

    //     frame = new JFrame("Grid");
    //     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	// 	fullscreen();	//makes the it stay on the left??
    //     frame.addKeyListener(this);

    //     int mapSize = Math.max(Math.min(500 / getNumRows(), 500 / getNumCols()), 1);
    //     setPreferredSize(new Dimension(mapSize * getNumCols(), mapSize * getNumRows()));
    //     addMouseListener(this);
    //     frame.getContentPane().add(this);

    //     frame.pack();
    //     frame.setVisible(true);

	// 	setBackground(defaultBgColor); //TODO add background

	// 	boardHeight = getHeight();
	// 	hexagonSide = 250 / (hexGen + 2);
	// 	//hexagonSide = 25;
	// 	//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
	// 	widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
	// 	System.out.println("Boardheight: " + boardHeight);
	// 	System.out.println("HexagonSide: " + hexagonSide);
	// 	System.out.println("WidthMargin: " + widthMargin);

	// 	this.addComponentListener(new ComponentListener() {

    // 		public void componentResized(ComponentEvent e) {
    // 		//	System.out.println(e.getComponent().getSize());
    // 			boardHeight = getHeight();
    // 			//hexagonSide = (boardHeight - 2 * heightMargin) / 8;
    // 			widthMargin = (getWidth() - (int) (10 * hexagonSide * sqrt3div2)) / 2;
    // 			//System.out.println("Boardheight: " + boardHeight);
    // 			//System.out.println("HexagonSide: " + hexagonSide);
    // 			//System.out.println("WidthMargin: " + widthMargin);
    // 		}

    // 		public void componentHidden(ComponentEvent e) {}

    // 		public void componentMoved(ComponentEvent e) {}

    // 		public void componentShown(ComponentEvent e) {}
    // 	});

    // }

    // private void load(String imageFileName) {
    //     showFullImage(loadImage(imageFileName));
    //     setTitle(imageFileName);
    // }

    // private void save(String imageFileName) {
    //     try {
    //         BufferedImage bi = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);
    //         paintComponent(bi.getGraphics());
    //         int index = imageFileName.lastIndexOf('.');
    //         if (index == -1)
    //             throw new RuntimeException("invalid image file name:  " + imageFileName);
    //         ImageIO.write(bi, imageFileName.substring(index + 1), new File(imageFileName));
    //     } catch ( IOException e) {
    //         throw new RuntimeException("unable to save image to file:  " + imageFileName);
    //     }
    // }

	// private BufferedImage loadImage(String imageFileName) {
		
	// 	if(imageFileName == null || "".equals(imageFileName)){
	// 		System.out.println("Image is null or \"\"");
	// 		return null;
	// 	} else{
	// 		final URL url = getClass().getResource(imageFileName);
	// 		if (url == null) {
	// 			throw new RuntimeException("cannot find file:  " + imageFileName);
	// 		}
	// 		try {
	// 			return ImageIO.read(url);
	// 		} catch (IOException e) {
	// 			throw new RuntimeException("unable to read from file:  " + imageFileName);
	// 		}
	// 	}
	// }


    // private void showFullImage(BufferedImage image) {
    //     for (int row = 0; row < getNumRows(); row++) {
    //         for (int col = 0; col < getNumCols(); col++) {
    //             int x = col * image.getWidth() / getNumCols();
    //             int y = row * image.getHeight() / getNumRows();
    //             int c = image.getRGB(x, y);

    //             int red = (c & 0x00ff0000) >> 16;
    //             int green = (c & 0x0000ff00) >> 8;
    //             int blue = c & 0x000000ff;

    //             map[row][col].setColor(new Color(red, green, blue));
    //         }
    //     }
    //     repaint();
    // }

  

	// private displayHexTile(){
	// 	pushMatrix();
	// 	translate(width*0.8, height*0.5);
	// 	polygon(0, 0, 70, 6);
	// 	popMatrix();
	// }

	//function that creates a n-sided polygon on a point circle
	private void hexagon(HexTile hTile) {
		int npoints = 6;
		float x = hTile.getCenterPixels().x;
		float y = hTile.getCenterPixels().y;
		float angle = TWO_PI / npoints;
		float radius = hTile.getRadius();
		beginShape();
		for (float a = 0; a < TWO_PI; a += angle) {
			float sx = x + cos(a) * radius;
			float sy = y + sin(a) * radius;
			vertex(sx, sy);
		}
		endShape(CLOSE);
	}



	public Polygon makeHex(Point center) {
		int xCenter = (int) center.getX();
		int yCenter = (int) center.getY();

		Polygon output = new Polygon();
		output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5f * hexagonSide) + 1);
		output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5f * hexagonSide) - 1);
		output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5f * hexagonSide) + 1);

		return output;
	}

	public PGraphics getHexPGraphics(HexTile hTile) {

		Point centerPixels = hTile.getCenterPixels();
		int xCenter = (int) centerPixels.getX();
		int yCenter = (int) centerPixels.getY();

		PGraphics pg = new PGraphics();

		// Polygon output = new Polygon();
		// output.addPoint(xCenter + 1, yCenter + hexagonSide + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter + (int) (.5 * hexagonSide) + 1);
		// output.addPoint(xCenter + (int) (hexagonSide * sqrt3div2) + 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter + 1, yCenter - hexagonSide - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter - (int) (.5 * hexagonSide) - 1);
		// output.addPoint(xCenter - (int) (hexagonSide * sqrt3div2) - 1, yCenter + (int) (.5 * hexagonSide) + 1);

		return pg;
	}

}  
/* HexLocation Class
 * HexLocations use x & y coordinate instead of row & column designations
 * Author: Joel Bianchi
 * Last Edit: 5/16/2023
 */

public class HexLocation extends GridLocation{
 
  private int xCoord;
  private int yCoord;
  
  public HexLocation(int x, int y) {
    super(x,y);
    xCoord = x;
    yCoord = y;
  }
  
  public int getYCoord() {
    return yCoord;
  }
  
  public int getXCoord() {
    return xCoord;
  }
  
  public boolean equals(HexLocation otherLoc) {
    return yCoord == otherLoc.getYCoord() && xCoord == otherLoc.getXCoord();
  }
  
  public String toString() {
    return "(" + xCoord + ", " + yCoord + ")";
  }


}
/* HexTile Class
 * Based off code from Naomi Gaylor & Ezzeldin Moussa, June 2022
 * Last edit: 5/16/2023
 * Edited to be a subclass of GridTile pde file
 */




public class HexTile extends GridTile{
  
  private Polygon hexPoly;
  private float radius;
  private Point centerPixels;
  //private HexLocation hexLoc;

  //HexTile Constructor #1: GridLocation
  public HexTile(HexLocation loc, float rad){
    super(loc);
    //this.hexLoc = loc;
    this.radius = rad;
    this.centerPixels = new Point(0,0);
    this.hexPoly = null;
  }

  //HexTile Constructor #2: X,Y coordinates
  public HexTile(int xCord, int yCord, float rad){
    this(new HexLocation(xCord,yCord), rad);
  }

  //method to access the location of the GridTile
  // public HexLocation getLocation(){
  //     return location;
  // }

  //mutator method to define the center point of the Tile
  public void setHexCenterPixels(Point centerPixels){
    this.centerPixels = centerPixels;
  }
  //accessor method to the center point of the Tile
  public Point getCenterPixels(){
    return centerPixels;
  }

  //mutator method to change the Java Polygon object that defines the shape of the HexTile
  public void setHexPoly(Polygon hexPoly){
    this.hexPoly = hexPoly;
  }
  //accessor method to return the Java Polygon object
  public Polygon getPoly(){
    return hexPoly;
  }

  //accessor method to return the hexagon's radius
  public float getRadius(){
    return radius;
  }

    
}  
/* Platform class
 * Stub constructors provided
 * Can be used with the following tutorials:
 * https://longbaonguyen.github.io/courses/platformer/platformer.html
 * Authors: __________________
 * Last Edit: 5/17/2023
 */

public class Platform {//extends Sprite {

	//Platform defined by it's center-x and top-Y positions
	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight, int clr) {

		//pass along the center-x and center-y to Sprite super
		//super(posXCenter, posYTop + (platHeight/2), clr);
		//System.out.println("PlatTopY: " + posYTop + "\tPlatCenterY: " + (posYTop + (platHeight/2)));
		// setWidth(platWidth);
		// setHeight(platHeight);
		//setColor(Color.black);
	}

	public Platform(float posXCenter, float posYTop, float platWidth, float platHeight) {
		//pass along the center-x and center-y to Sprite super
		this(posXCenter, posYTop, platWidth, platHeight, color(0,0,0));
	}

}
/* Screen class - a high level class that handles background screens & millisecond timing
 * Has a World Subclass
 * Author: Joel Bianchi
 * Last Edit: 6/6/23
 */

public class Screen {

    //Screen fields
    private String screenName;
    private PImage bg;
    private float x;
    private float y;

    private long startTime;
    private long lastTime = 0;

    //Screen Constructor #1
    public Screen(String screenName, PImage bg, float x, float y) {
        this.setName(screenName);
        if(bg != null) {
            this.setBg(bg);
        }
        this.x = x;
        this.y = y;
        startTime = getTotalTime();
    }

    //Screen Constructor #2
    public Screen(String screenName, PImage bg) {
        this(screenName, bg, 0.0f, 0.0f);
    }

    //Screen Accessors + Mutators
    public void setName(String screenName){
        this.screenName = screenName;
    }
    public String getName(){
        return screenName;
    }

    public void setBg(PImage bg){
        this.bg = bg;
        //background(bg);
    }
    public PImage getBg(){
        return bg;
    }
    
    public void setX(float x) {
        this.x = x;
    }
    public float getX() {
        return x;
    }

    public void setY(float y) {
        this.y = y;
    }
    public float getY() {
        return y;
    }

    //???
    public void setScreenSize(int w, int h){

    }

    public String toString(){
        return "Screen: " + screenName + " at " + x + "," + y;
    }

    public void pause(final int milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (final Exception e) {
            System.out.println(e);
        }
    }

    //SCREEN TIME METHODS
    public long getTotalTime(){
        return millis();  //milliseconds world
    }
    public long getScreenTime(){
        return millis() - startTime;  //milliseconds world
    }
    public long getTimeSince(long lastCheck){
        return getScreenTime() - lastCheck;
    }
    public float getScreenTimeSeconds(){
        return getScreenTime() / 1000.0f;
    }

}
/* Sprite class - to create objects that move around with their own properties
 * Inspired by Daniel Shiffman's p5js Animated Sprite tutorial
 * Author: Joel Bianchi
 * Last Edit: 6/5/23
 * Modified to account for picture coordinates at Top, Left corner
 * Added Constructor #3
 * spriteImgPath renamed to spriteImgFile
 * variable renaming
 * sprite copying
 */

public class Sprite {
  
    PImage spriteImg;
    private String spriteImgFile;
    private float centerX;
    private float centerY;
    private float speedX;
    private float speedY;
    private float w;
    private float h;
    private boolean isAnimated;


  // Sprite Constructor #1
  public Sprite(String spriteImgFile, float scale, float x, float y, boolean isAnimated) {
    this.spriteImgFile = spriteImgFile;
    setLeft(x);
    setTop(y);
    this.speedX = 0;
    this.speedY = 0;
    this.isAnimated = isAnimated;
    if(!isAnimated){
      this.spriteImg = loadImage(spriteImgFile);
      w = spriteImg.width * scale;
      h = spriteImg.height * scale;
    }
  }

  // Sprite Constructor #2: for Non-Animated Sprite
  public Sprite(String spriteImgFile, float x, float y) {
    this(spriteImgFile, 1.0f, x, y, false);
  }

  // Sprite Constructor #3: Only pass in the image
  public Sprite(String spriteImgFile){
    this(spriteImgFile, 0.0f, 0.0f);
  }


  // method to display the Sprite image on the screen
  public void show() {
      image(spriteImg, getLeft(), getTop(), w, h);
  }

  // method to move Sprite image on the screen to a specific coordinate
  public void moveTo(float x, float y){
    setLeft(x);
    setTop(y);
  }

  // method to move Sprite image on the screen relative to current position
  public void move(float changeX, float changeY){
    this.centerX += changeX;
    this.centerY += changeY;
    //System.out.println(getLeft() + "," + getTop());
  }

  //method to change the speed of the Sprite
  public void setSpeed( float speedX, float speedY){
    this.speedX = speedX;
    this.speedY = speedY;
  }


  // method that automatically moves the Sprite based on its velocity
  public void update(){
    move(speedX, speedY);
  }
  public void update(float deltaTime){
    speedX += deltaTime/1000;
    speedY += deltaTime/1000;
    move(speedX, speedY);
  }

  // method to rotate Sprite image on the screen
  public void rotate(float degrees){
    float rads = radians(degrees);
    translate(centerX,centerY);
    rotate(rads);
  }


  /*-- ACCESSOR METHODS --*/

  public float getW(){
    return w;
  }
  public float getH(){
    return h;
  }
  public float getCenterX(){
    return centerX;
  }
  public float getCenterY(){
    return centerY;
  }
  public PImage getImg(){
    return spriteImg;
  }
  public boolean getIsAnimated(){
    return isAnimated;
  }
  
  
  /*-- MUTATOR METHODS --*/
  public void setW(float w){
    this.w = w;
  }
  public void setH(float h){
    this.h=h;
  }
  public void setCenterX(float centerX){
    this.centerX = centerX;
  }
  public void setCenterY(float centerY){
    this.centerY=centerY;
  }
  public void setImg(PImage img){
    this.spriteImg = img;
  }
  public void setIsAnimated(boolean a){
    isAnimated = a;
  }


  /*-- SPRITE BOUNDARY METHODS --
    -- Used from Long Bao Nguyen
    -- https://longbaonguyen.github.io/courses/platformer/platformer.html
  */
   public void setLeft(float left){
    centerX = left + w/2;
  }
   public float getLeft(){
    return centerX - w/2;
  }
   public void setRight(float right){
    centerX = right - w/2;
  }
   public float getRight(){
    return centerX + w/2;
  }
   public void setTop(float top){
    centerY = top + h/2;
  }
   public float getTop(){
    return centerY - h/2;
  }
   public void setBottom(float bottom){
    centerY = bottom - h/2;
  }
   public float getBottom(){
    return centerY + h/2;
  }

  //Accessor method to the image path of the Sprite
  public String getImagePath(){
    return this.spriteImgFile;
  }
  
  //Accessor method to the image path of the Sprite
  public PImage getImage(){
    return this.spriteImg;
  }

  //Method to copy a Sprite to a specific location
  public Sprite copyTo(float x, float y){

    PImage si = this.spriteImg;
    String sif = this.spriteImgFile;
    float cx = this.centerX;
    float cy = this.centerY;
    float sx = this.speedX;
    float sy = this.speedY;
    float w = this.w;
    float h = this.h;
    boolean ia = this.isAnimated;
    
    Sprite sp = new Sprite(sif, 1.0f, x, y, ia);
    sp.setSpeed(sx,sy);
    sp.setW(w);
    sp.setH(h);

    return sp;

  }
  //Method to copy a Sprite to same location
  public Sprite copy(){
    return copyTo(this.centerX, this.centerY);
  }

  //Method to check if 2 Sprites are the same (based on PImage)
  public boolean equals(Sprite otherSprite){
    if(this.spriteImgFile != null && otherSprite != null && this.spriteImgFile.equals(otherSprite.getImagePath())){
      return true;
    }
    return false;
  }

  public String toString(){
    return spriteImgFile + "\t" + getLeft() + "\t" + getTop() + "\t" + speedX + "\t" + speedY + "\t" + w + "\t" + h + "\t" + isAnimated;
  }

}
/* The station class is a class that changes the background of the game as though the player is going 
to a different room. The room changes if the player character interacts with specific collision points
on the grid system.*/
/*
public class Station extends Game{
    private PImage diffBg;

    public Station(){
        Screen default = splashScreen;
    }

    public void changeBg(diffBg){
        screen.setBg(diffBg);

    }

}
*/
/* World Class - Used to describe the screen of a pixel-based game
 * Subclass of a Screen, but now includes an ArrayList of AnimatedSprite objects
 * Authors: Joel Bianchi, Nathan Santos, Clive Sherwood
 * Last Edit: 6/6/2023
 * Modified for Processing
 * Can add copied sprites
 * Made a subclass of Screen
 */



public class World extends Screen{

  //World Fields
  //private static World currentWorld = null;
  private ArrayList<AnimatedSprite> sprites = new ArrayList<AnimatedSprite>();
  long lastTime = 0;

  //WORLD CONSTRUCTORS
  //World Constructor #1
  public World(String name, PImage bgImg) {
    super(name, bgImg);
  }
  //World Constructor #2
  public World(String name) {
    this(name, null);
  }
    //World Constructor #3
  public World() {
    this("default world", null);
  }


  //WORLD SPRITE METHODS
  public ArrayList<AnimatedSprite> getSprites(){
      return sprites;
  }

  //method to add a sprite to the world
  public void addSprite(AnimatedSprite sprite) {
    if (!sprites.contains(sprite)) {
      sprites.add(sprite);
    }
  }

  //method to add a copy of a sprite to a specific coordinate in the world
  public void addSpriteCopyTo(AnimatedSprite sprite, float x, float y) {
    sprites.add(sprite.copyTo(x,y));
  }

  //method to add a copy of a sprite to the world
  public void addSpriteCopy(AnimatedSprite sprite) {
    sprites.add(sprite.copy());
  }

  //method to remove a sprite from the world
  public void removeSprite(AnimatedSprite sprite) {
    if (sprites.contains(sprite)) {
      sprites.remove(sprite);
    }
  }

  //method to display all the sprites on the screen
  public void showSprites(){
    //System.out.println("showing sprites...");
    //Loop through all the sprites
    for(AnimatedSprite sprite : sprites){
        sprite.show();        
    }
  }

  //method to print out list of sprites
  public void printSprites(){
      for(Sprite sprite: sprites){
          System.out.println(sprite);
      }
  }


  //WORLD MUTATOR METHODS
  
  //method to update all sprites in the world each cycle
  public void update() {
    long deltaTime = getTimeSince(lastTime);
    for (AnimatedSprite sprite : sprites) {
      sprite.update(deltaTime);
    }
    lastTime = getScreenTime();
  }

}


  public void settings() { size(800, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Game" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
